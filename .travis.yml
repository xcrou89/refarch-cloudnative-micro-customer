sudo: required
language: java
dist: xenial
jdk:
  - openjdk8
stages:
  - local build and test
  - kubernetes build, deploy, and test
jobs:
  include:
    - stage: local build and test
      services:
      - docker
      env:
        - zipkinHost=localhost
        - zipkinPort=9411
        - jwksUri=https://localhost:9443/oidc/endpoint/OP/jwk
        - jwksIssuer=https://localhost:9443/oidc/endpoint/OP
        - administratorRealm=https://localhost:9443/oidc/endpoint/OP
        - customerHttpPort=9084
        - customerHttpsPort=9445        
        - CDB_PORT=5984
        - POPULATE_IMAGE=ibmcase/populate
        - COUCHDB_HOST=localhost
        - COUCHDB_PORT=5984
      before_script:
      # Pull the CouchDB Docker image
      - docker pull couchdb:2.3.1
      # Setup and run CouchDB
      - docker run -p ${CDB_PORT}:5984 -e COUCHDB_USER=admin -e COUCHDB_PASSWORD=passw0rd -d couchdb --hostname cloudant.dev
      # Wait for CouchDB to Start
      - sleep 20
      # Check CouchDB status
      - curl http://localhost:$CDB_PORT
      # Fetch network IP: Use jq to parse and use sed to remove quotes
      - export GATEWAY=$(docker network inspect bridge | jq '.[].IPAM.Config' | jq '.[].Gateway' | sed 's/"//g')
      # Create the populate image
      - cd populate/
      - docker build -t $POPULATE_IMAGE .
      - docker run $POPULATE_IMAGE $GATEWAY $CDB_PORT
      # Verify local DB population
      - chmod +x ./test_populate.sh
      - sudo ./test_populate.sh
      - cd -
      # Define a Keystore
      - bash scripts/keygen.sh
      - sudo cp -r keystorevol /etc/
      # Swap MP Config for local testing
      - cd src/main/resources/META-INF
      - mv microprofile-config.properties      .microprofile-config.properties # Make hidden
      - mv microprofile-config.properties.local microprofile-config.properties # Make main
      - cd -
      # Create Auth, put keystore in, and start it
      - docker pull ibmcase/auth-mp:v4.0.0
      - docker create --name auth -p 9443:9443 -p 9080:9080 ibmcase/auth-mp:v4.0.0
      - docker cp keystorevol auth:/etc/
      - docker start auth
      script:
      # Maven Build
      - mvn clean install
      # Start Application
      - mvn liberty:start -DtestServerHttpPort=$customerHttpPort -DtestServerHttpsPort=$customerHttpsPort
      - sleep 20
      # Run Catalog API Test
      - bash scripts/api_tests.sh localhost $customerHttpsPort
    - stage: kubernetes build, deploy, and test
      services:
      - docker
      env:
      - CHANGE_MINIKUBE_NONE_USER=true
      - RELEASE_NAME=customer
      - IMAGE_NAME=customer
      - IMAGE_TAG=travis
      - POPULATE_IMAGE=ibmcase/populate
      install:
      - true
      before_script:
      - curl -O https://raw.githubusercontent.com/ibm-cloud-architecture/refarch-cloudnative-kubernetes/microprofile/utility_scripts/install_minikube_and_helm.sh
      - chmod +x install_minikube_and_helm.sh
      - bash install_minikube_and_helm.sh
      # Add helm repos
      - helm repo add incubator http://storage.googleapis.com/kubernetes-charts-incubator
      - helm repo add services-bc-mp https://raw.githubusercontent.com/ibm-cloud-architecture/refarch-cloudnative-kubernetes/microprofile/docs/charts/services-bc-mp
      - helm repo add bc-auth https://raw.githubusercontent.com/ibm-cloud-architecture/refarch-cloudnative-auth/microprofile/chart/release
      # Run Kubernetes Job and run Auth (May not need keystore chart)
      - helm install --name keystore services-bc-mp/keystore
      - helm install --name auth bc-auth/auth
      - MINIKUBE_IP=$(minikube ip)
      - AUTH_NODE_PORT=$(kubectl get service auth-auth -o=jsonpath='{.spec.ports[1].nodePort}')
      # Define a Keystore
      - bash scripts/keygen.sh
      - sudo cp -r keystorevol /etc/
      script:
      # Maven Build
      - mvn clean install
      # Build Docker image
      - docker build -t $IMAGE_NAME:$IMAGE_TAG .
      # Create the populate image
      - cd populate/
      - docker build -t $POPULATE_IMAGE . # <-- Temporary solution until populate image is updated. Or maybe we keep.
      - cd -
      # Install Customer <-- Reminder to update the load_data.yaml to point to agreed populate image later
      - helm dependency update ./chart/customer
      - helm install --set travis=true --set service.minikubeIp=$MINIKUBE_IP --set service.authKubePort=$AUTH_NODE_PORT --set image.repository=$IMAGE_NAME --set image.tag=$IMAGE_TAG --name $RELEASE_NAME ./chart/customer/
      # Wait for CouchDB to be installed and populated from Customer installation
      - COMPLETION=$( kubectl get jobs -o json | jq '.items | .[] | select(.metadata.name=="customer-customer-populate") | .status.succeeded' )
      - echo $COMPLETION
      - until [ -n "$COMPLETION" ] && [ $COMPLETION -ge 1 ]; do COMPLETION=$( kubectl get jobs -o json | jq '.items | .[] | select(.metadata.name=="customer-customer-populate") | .status.succeeded' ); kubectl get pods -o wide; echo "Waiting for customer populate job to be completed"; sleep 10; done
      # Wait for Customer to be ready
      - kubectl get deployments ${RELEASE_NAME}-customer -o yaml
      - READY=$(kubectl get deployments ${RELEASE_NAME}-customer -o yaml | grep "readyReplicas" | awk '{print $2}')
      - echo $READY
      - until [ -n "$READY" ] && [ ${READY} -ge 1 ]; do READY=$(kubectl get deployments ${RELEASE_NAME}-customer -o yaml | grep "readyReplicas" | awk '{print $2}'); kubectl get deployments -o wide; echo "Waiting for customer to be ready"; sleep 10; done
      # Run auth API Test
      - CUST_NODE_PORT=$(kubectl get service ${RELEASE_NAME}-customer -o=jsonpath='{.spec.ports[1].nodePort}')
      - bash scripts/api_tests.sh $MINIKUBE_IP $CUST_NODE_PORT $MINIKUBE_IP $AUTH_NODE_PORT